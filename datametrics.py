from matplotlib import pyplot as plt
import numpy as np

class DataMetrics(object):
    """A class that holds all statistical measurements generated by the
    network simulation.

    Attributes:
        buffer_occupancy (dict): holds buffer occupancy data for each link.
            The key is the link_id and the value is an array of
            (time, buffer_occupancy) tuples.
        packet_loss (dict): holds packet loss data for each link.
            The key is the link_id and the value is an array of
            (time, packet_loss) tuples.
        link_rate (dict): holds link rate data for each link.
            The key is the link_id and the value is an array of
            (time, amount of data sent) tuples.
        flow_rate (dict): holds flow rate data for each flow.
            The key is the flow_id and the value is an array of
            (time, amount of data sent) tuples.
        window_size (dict): holds window size data for each flow.
            The key is the flow_id and the value is an array of
            (time, window size) tuples.
        flow_packet_delay (dict): holds roundtrip time data for each flow
            The key is the flow_id and the value is an array of
            (time of acknowledgement, roundtrip time) tuples.
        flow_packet_sent_time (dict): holds data on when each packet was sent,
            to be used for calculating the roundtrip time. The key is the
            (flow_id, packet_id) and the value is the sent time.

    """

    def __init__(self):
        self.buffer_occupancy = {}
        self.packet_loss = {}
        self.link_rate = {}
        self.flow_rate = {}
        self.window_size = {}
        self.flow_packet_delay = {}
        self.flow_packet_sent_time = {}

    def update_buffer_occupancy(self, link_id, buffer_occupancy, time):
        """Add a buffer occupancy data point, or modify a previously added
        point.

        Args:
            link_id (str): the id of the link with the buffer occupancy.
            buffer_occupancy (float): the buffer occupancy of the link in bits.
            time (float): the time of this data point.

        """
        prev_buffer_occupancy = 0
        if link_id not in self.buffer_occupancy:
            self.buffer_occupancy[link_id] = []
        # If there is a previous data point with the same time, update
        # the point.
        elif self.buffer_occupancy[link_id][-1][0] == time:
            prev_buffer_occupancy = self.buffer_occupancy[link_id][-1][1]
            self.buffer_occupancy[link_id].pop()
        data_point = (time, prev_buffer_occupancy + buffer_occupancy)
        self.buffer_occupancy[link_id].append(data_point)

    def update_packet_loss(self, link_id, time):
        """Add a packet loss data point, or modify a previously added point.

        Args:
            link_id (str): the id of the link with the packet loss.
            time (float): the time of this data point.

        """
        prev_dropped_packets = 0
        if link_id not in self.packet_loss:
            self.packet_loss[link_id] = []
        # If there is a previous data point with the same time, update
        # the point.
        elif self.packet_loss[link_id][-1][0] == time:
            prev_dropped_packets = self.packet_loss[link_id][-1][1]
            self.packet_loss[link_id].pop()
        data_point = (time, prev_dropped_packets + 1)
        self.packet_loss[link_id].append(data_point)

    def update_link_rate(self, link_id, amt_sent, time):
        """Add a link rate data point, or modify a previously added point.

        Args:
            link_id (str): the id of the link for this data point.
            amt_sent (float): the amount of data sent by the link in bits.
            time (float): the time of this data point.

        """
        prev_amt_sent = 0
        if link_id not in self.link_rate:
            self.link_rate[link_id] = []
        # If there is a previous data point with the same time, update
        # the point.
        elif self.link_rate[link_id][-1][0] == time:
            prev_amt_sent = self.link_rate[link_id][-1][1]
            self.link_rate[link_id].pop()
        data_point = (time, prev_amt_sent + amt_sent)
        self.link_rate[link_id].append(data_point)

    def update_flow_rate(self, flow_id, amt_sent, time):
        """Add a flow rate data point, or modify a previously added point.

        Args:
            flow_id (str): the id of the flow for the data point.
            amt_sent (float): the amount of data sent by the flow in bits.
            time (float): the time of this data point.

        """
        prev_amt_sent = 0
        if flow_id not in self.flow_rate:
            self.flow_rate[flow_id] = []
        # If there is a previous data point with the same time, update
        # the point.
        elif self.flow_rate[flow_id][-1][0] == time:
            prev_amt_sent = self.flow_rate[flow_id][-1][1]
            self.flow_rate[flow_id].pop()
        data_point = (time, prev_amt_sent + amt_sent)
        self.flow_rate[flow_id].append(data_point)

    def update_window_size(self, flow_id, window_size, time):
        """Add a window size data point, or modify a previously added point.

        Args:
            flow_id (str): the id of the flow for the data point.
            window_size (int): the window size of the flow at the given time.
            time (float): the time of this data point.

        """
        prev_window_size = 0
        if flow_id not in self.window_size:
            self.window_size[flow_id] = []
        # If there is a previous data point with the same time, update
        # the point.
        elif self.window_size[flow_id][-1][0] == time:
            prev_window_size = self.window_size[flow_id][-1][1]
            self.window_size[flow_id].pop()
        data_point = (time, prev_window_size + window_size)
        self.window_size[flow_id].append(data_point)

    def update_packet_send_time(self, flow_id, packet_id, time):
        """Record the most recent time a packet was sent, for use in
        calculating the roundtrip time.

        Args:
            flow_id (str): the id of the flow that the packet belongs to.
            packet_id (int): the id of the packet being sent.
            time (float): the time the packet was last sent.

        """
        self.flow_packet_sent_time[(flow_id, packet_id)] = time

    def update_packet_ack_time(self, flow_id, packet_id, time):
        """Records the acknowledgement of a packet, for use in
        calculating the roundtrip time.

        Args:
            flow_id (str): the id of the flow that the packet belongs to.
            packet_id (int): the id of the packet being sent.
            time (float): the time the packet was acknowledged.

        """
        if (flow_id, packet_id) not in self.flow_packet_sent_time:
            raise Exception("Packet send time not set for packet %s "
                            "in flow %s" % (packet_id, flow_id))
        rtt = time - self.flow_packet_sent_time[(flow_id, packet_id)]
        self._update_flow_packet_delay(flow_id, rtt, time)

    def _update_flow_packet_delay(self, flow_id, packet_delay, time):
        """Records the roundtrip time for a packet in a flow.

        Args:
            flow_id (str): the id of the flow that the packet belongs to.
            packet_delay (int): the roundtrip time of the packet.
            time (float): the time the packet was acknowledged.

        """
        if flow_id not in self.flow_packet_delay:
            self.flow_packet_delay[flow_id] = []
        data_point = (time, packet_delay)
        self.flow_packet_delay[flow_id].append(data_point)

    def plot_buffer_occupancy(self):
        legend_labels = []
        for link_id in self.buffer_occupancy:
            if link_id == "L1" or link_id == "L3":
                data = np.array(self.buffer_occupancy[link_id])

                x, y = zip(*data)
                plt.plot(x, y, 'o')
                legend_labels.append(link_id)
                

        plt.legend(legend_labels)
        plt.show()

    def plot_flow_rate(self):
        legend_names = []
        for flow_id in self.flow_rate:
            data = self.flow_rate[flow_id]
            time_arr = []
            flow_rate_arr = []

            interval_size = len(data) / 200

            num_intervals = int(np.ceil(len(data) * 1.0 / interval_size))

            for i in range(num_intervals):
                sum_amt_sent = 0.0
                sum_time = 0.0
                num_data = 0

                for j in range(interval_size):
                    if i * interval_size + j < len(data):
                        time, amt_sent = data[i * interval_size + j]
                        sum_amt_sent += amt_sent
                        sum_time += time
                        num_data += 1

                first_index = i * interval_size
                last_index = i * interval_size + num_data - 1
                time_range = data[last_index][0] - data[first_index][0]

                time_arr.append(sum_time / num_data)
                flow_rate_arr.append(sum_amt_sent / time_range)

            plt.plot(time_arr, flow_rate_arr, 'o')
            legend_names.append(flow_id)

        plt.legend(legend_names)
        plt.show()

    def plot_flow_packet_delay(self):
        legend_names = []
        for flow_id in self.flow_rate:
            data = self.flow_packet_delay[flow_id]
            time_arr = []
            flow_delay_arr = []

            interval_size = len(data) / 200

            num_intervals = int(np.ceil(len(data) * 1.0 / interval_size))

            for i in range(num_intervals):
                sum_delay = 0.0
                sum_time = 0.0
                num_data = 0

                for j in range(interval_size):
                    if i * interval_size + j < len(data):
                        time, delay = data[i * interval_size + j]
                        sum_delay += delay
                        sum_time += time
                        num_data += 1

                time_arr.append(sum_time / num_data)
                flow_delay_arr.append(sum_delay / num_data)

            plt.plot(time_arr, flow_delay_arr, 'o')
            legend_names.append(flow_id)

        plt.legend(legend_names)
        plt.show()


def movingaverage (values, window):
    weights = np.repeat(1.0, window)/window
    sma = np.convolve(values, weights, 'valid')
    return sma






















